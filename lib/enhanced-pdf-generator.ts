import jsPDF from 'jspdf';
import { AIDocumentFormatter } from './ai-document-formatter';

export interface EnhancedPDFOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  content: string;
  useAIFormatting?: boolean;
  fontSize?: number;
  fontFamily?: string;
  margins?: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  };
  pageSize?: 'a4' | 'letter' | 'legal';
  orientation?: 'portrait' | 'landscape';
  includeHeader?: boolean;
  includeFooter?: boolean;
  headerText?: string;
  footerText?: string;
}

export interface ParsedContent {
  title: string;
  sections: Array<{
    title: string;
    content: string;
    level: number;
  }>;
  tables: Array<{
    title?: string;
    headers: string[];
    rows: string[][];
  }>;
  lists: Array<{
    type: 'ordered' | 'unordered';
    items: string[];
  }>;
}

export class EnhancedPDFGenerator {
  private aiFormatter: AIDocumentFormatter;
  private doc: jsPDF;
  private currentY: number = 20;
  private pageHeight: number = 297; // A4 height in mm
  private margins: { top: number; right: number; bottom: number; left: number };

  constructor() {
    this.aiFormatter = new AIDocumentFormatter();
    this.doc = new jsPDF();
    this.margins = { top: 20, right: 20, bottom: 20, left: 20 };
  }

  async generatePDF(options: EnhancedPDFOptions): Promise<Buffer> {
    const {
      title = 'Generated Document',
      author = 'Document Assistant',
      subject = '',
      keywords = [],
      content,
      useAIFormatting = true,
      fontSize = 12,
      fontFamily = 'helvetica',
      margins = { top: 20, right: 20, bottom: 20, left: 20 },
      pageSize = 'a4',
      orientation = 'portrait',
      includeHeader = false,
      includeFooter = true,
      headerText = '',
      footerText = 'Generated by Document Assistant'
    } = options;

    // Initialize PDF with options
    this.doc = new jsPDF({
      orientation,
      unit: 'mm',
      format: pageSize
    });

    this.margins = margins;
    this.currentY = margins.top;
    this.pageHeight = pageSize === 'a4' ? 297 : pageSize === 'letter' ? 279 : 356;

    // Set document properties
    this.doc.setProperties({
      title,
      author,
      subject,
      keywords: keywords.join(', '),
      creator: 'Document Assistant'
    });

    // Set default font
    this.doc.setFont(fontFamily);
    this.doc.setFontSize(fontSize);

    let processedContent = content;

    // Use AI formatting if enabled
    if (useAIFormatting) {
      try {
        processedContent = await this.aiFormatter.format(content);
      } catch (error) {
        console.warn('AI formatting failed, using original content:', error);
      }
    }

    // Parse the content
    const parsedContent = this.parseContent(processedContent);

    // Add header if enabled
    if (includeHeader && headerText) {
      this.addHeader(headerText);
    }

    // Generate document content
    await this.generateContent(parsedContent, fontSize);

    // Add footer if enabled
    if (includeFooter && footerText) {
      this.addFooter(footerText);
    }

    return Buffer.from(this.doc.output('arraybuffer') as ArrayBuffer);
  }

  private parseContent(content: string): ParsedContent {
    const lines = content.split('\n');
    const parsed: ParsedContent = {
      title: '',
      sections: [],
      tables: [],
      lists: []
    };

    let currentSection: { title: string; content: string; level: number } | null = null;
    let currentTable: { title?: string; headers: string[]; rows: string[][] } | null = null;
    let currentList: { type: 'ordered' | 'unordered'; items: string[] } | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      if (!line) continue;

      // Parse headers (# ## ###)
      const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headerMatch) {
        const level = headerMatch[1].length;
        const title = headerMatch[2];

        if (level === 1 && !parsed.title) {
          parsed.title = title;
        } else {
          if (currentSection) {
            parsed.sections.push(currentSection);
          }
          currentSection = { title, content: '', level };
        }
        continue;
      }

      // Parse tables (| header | header |)
      if (line.includes('|') && line.split('|').length > 2) {
        if (!currentTable) {
          const headers = line.split('|').map(h => h.trim()).filter(h => h);
          currentTable = { headers, rows: [] };
        } else if (!line.includes('---')) {
          const row = line.split('|').map(c => c.trim()).filter(c => c);
          if (row.length === currentTable.headers.length) {
            currentTable.rows.push(row);
          }
        }
        continue;
      } else if (currentTable) {
        parsed.tables.push(currentTable);
        currentTable = null;
      }

      // Parse lists (- item or 1. item)
      const unorderedListMatch = line.match(/^[-*+]\s+(.+)$/);
      const orderedListMatch = line.match(/^\d+\.\s+(.+)$/);

      if (unorderedListMatch || orderedListMatch) {
        const item = (unorderedListMatch || orderedListMatch)![1];
        const type = unorderedListMatch ? 'unordered' : 'ordered';

        if (!currentList || currentList.type !== type) {
          if (currentList) {
            parsed.lists.push(currentList);
          }
          currentList = { type, items: [item] };
        } else {
          currentList.items.push(item);
        }
        continue;
      } else if (currentList) {
        parsed.lists.push(currentList);
        currentList = null;
      }

      // Regular content
      if (currentSection) {
        currentSection.content += line + '\n';
      } else if (!parsed.title) {
        // If no title found, use first line as title
        parsed.title = line;
      }
    }

    // Add remaining items
    if (currentSection) {
      parsed.sections.push(currentSection);
    }
    if (currentTable) {
      parsed.tables.push(currentTable);
    }
    if (currentList) {
      parsed.lists.push(currentList);
    }

    return parsed;
  }

  private async generateContent(parsedContent: ParsedContent, baseFontSize: number): Promise<void> {
    // Add title
    if (parsedContent.title) {
      this.addTitle(parsedContent.title, baseFontSize + 8);
    }

    // Add sections
    for (const section of parsedContent.sections) {
      this.addSection(section, baseFontSize);
    }

    // Add tables
    for (const table of parsedContent.tables) {
      this.addTable(table, baseFontSize);
    }

    // Add lists
    for (const list of parsedContent.lists) {
      this.addList(list, baseFontSize);
    }
  }

  private addTitle(title: string, fontSize: number): void {
    this.checkPageBreak(fontSize + 10);
    this.doc.setFontSize(fontSize);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(title, this.margins.left, this.currentY);
    this.currentY += fontSize + 10;
    this.doc.setFont('helvetica', 'normal');
  }

  private addSection(section: { title: string; content: string; level: number }, baseFontSize: number): void {
    const headerSize = baseFontSize + (6 - section.level * 2);
    
    this.checkPageBreak(headerSize + 5);
    
    // Add section title
    this.doc.setFontSize(headerSize);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(section.title, this.margins.left, this.currentY);
    this.currentY += headerSize + 5;
    
    // Add section content
    this.doc.setFontSize(baseFontSize);
    this.doc.setFont('helvetica', 'normal');
    
    const lines = this.doc.splitTextToSize(section.content.trim(), 
      this.doc.internal.pageSize.width - this.margins.left - this.margins.right);
    
    for (const line of lines) {
      this.checkPageBreak(baseFontSize + 2);
      this.doc.text(line, this.margins.left, this.currentY);
      this.currentY += baseFontSize + 2;
    }
    
    this.currentY += 5; // Extra spacing after section
  }

  private addTable(table: { title?: string; headers: string[]; rows: string[][] }, baseFontSize: number): void {
    if (table.title) {
      this.checkPageBreak(baseFontSize + 5);
      this.doc.setFontSize(baseFontSize + 2);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text(table.title, this.margins.left, this.currentY);
      this.currentY += baseFontSize + 7;
    }

    const tableWidth = this.doc.internal.pageSize.width - this.margins.left - this.margins.right;
    const colWidth = tableWidth / table.headers.length;
    const rowHeight = baseFontSize + 4;

    // Check if table fits on current page
    const tableHeight = (table.rows.length + 1) * rowHeight;
    this.checkPageBreak(tableHeight);

    // Draw headers
    this.doc.setFontSize(baseFontSize);
    this.doc.setFont('helvetica', 'bold');
    
    for (let i = 0; i < table.headers.length; i++) {
      const x = this.margins.left + (i * colWidth);
      this.doc.rect(x, this.currentY - baseFontSize, colWidth, rowHeight);
      this.doc.text(table.headers[i], x + 2, this.currentY);
    }
    this.currentY += rowHeight;

    // Draw rows
    this.doc.setFont('helvetica', 'normal');
    for (const row of table.rows) {
      for (let i = 0; i < row.length; i++) {
        const x = this.margins.left + (i * colWidth);
        this.doc.rect(x, this.currentY - baseFontSize, colWidth, rowHeight);
        this.doc.text(row[i], x + 2, this.currentY);
      }
      this.currentY += rowHeight;
    }

    this.currentY += 10; // Extra spacing after table
  }

  private addList(list: { type: 'ordered' | 'unordered'; items: string[] }, baseFontSize: number): void {
    this.doc.setFontSize(baseFontSize);
    this.doc.setFont('helvetica', 'normal');

    for (let i = 0; i < list.items.length; i++) {
      this.checkPageBreak(baseFontSize + 2);
      
      const bullet = list.type === 'ordered' ? `${i + 1}.` : 'â€¢';
      const text = `${bullet} ${list.items[i]}`;
      
      const lines = this.doc.splitTextToSize(text, 
        this.doc.internal.pageSize.width - this.margins.left - this.margins.right - 10);
      
      for (const line of lines) {
        this.checkPageBreak(baseFontSize + 2);
        this.doc.text(line, this.margins.left + 5, this.currentY);
        this.currentY += baseFontSize + 2;
      }
    }

    this.currentY += 5; // Extra spacing after list
  }

  private addHeader(headerText: string): void {
    const pageCount = this.doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      this.doc.setPage(i);
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'normal');
      this.doc.text(headerText, this.margins.left, 10);
    }
  }

  private addFooter(footerText: string): void {
    const pageCount = this.doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      this.doc.setPage(i);
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'normal');
      
      const pageText = `${footerText} - Page ${i} of ${pageCount}`;
      const textWidth = this.doc.getTextWidth(pageText);
      const x = (this.doc.internal.pageSize.width - textWidth) / 2;
      
      this.doc.text(pageText, x, this.pageHeight - 10);
    }
  }

  private checkPageBreak(requiredSpace: number): void {
    if (this.currentY + requiredSpace > this.pageHeight - this.margins.bottom) {
      this.doc.addPage();
      this.currentY = this.margins.top;
    }
  }
}

export const enhancedPDFGenerator = new EnhancedPDFGenerator();