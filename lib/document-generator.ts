import jsPDF from 'jspdf';
import ExcelJS from 'exceljs';
import puppeteer from 'puppeteer';

export interface DocumentGenerationOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  format: 'pdf' | 'excel' | 'html' | 'docx';
  content: string;
  data?: any[];
  template?: 'report' | 'table' | 'presentation' | 'custom';
}

export class DocumentGenerator {
  
  async generatePDF(options: DocumentGenerationOptions): Promise<Buffer> {
    const { title = 'Generated Document', author = 'Document Assistant', content } = options;
    
    const doc = new jsPDF();
    
    // Set document properties
    doc.setProperties({
      title,
      author,
      subject: options.subject || '',
      keywords: options.keywords?.join(', ') || '',
      creator: 'Document Assistant'
    });
    
    // Add title
    doc.setFontSize(20);
    doc.text(title, 20, 30);
    
    // Add content
    doc.setFontSize(12);
    const lines = doc.splitTextToSize(content, 170);
    doc.text(lines, 20, 50);
    
    return Buffer.from(doc.output('arraybuffer') as ArrayBuffer);
  }
  
  async generateExcel(options: DocumentGenerationOptions): Promise<Buffer> {
    const { title = 'Generated Document', data = [], content } = options;
    
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'Document Assistant';
    workbook.created = new Date();
    
    const worksheet = workbook.addWorksheet(title);
    
    if (data.length > 0) {
      // If data is provided, create a table
      const headers = Object.keys(data[0]);
      worksheet.addRow(headers);
      
      data.forEach(row => {
        const values = headers.map(header => row[header]);
        worksheet.addRow(values);
      });
      
      // Style the header row
      const headerRow = worksheet.getRow(1);
      headerRow.font = { bold: true };
      headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };
    } else {
      // If no data, add content as text
      const lines = content.split('\n');
      lines.forEach((line, index) => {
        worksheet.addRow([line]);
      });
    }
    
    // Auto-fit columns
    worksheet.columns.forEach(column => {
      column.width = 15;
    });
    
    const buffer = await workbook.xlsx.writeBuffer();
    return Buffer.from(buffer);
  }
  
  async generateHTML(options: DocumentGenerationOptions): Promise<string> {
    const { title = 'Generated Document', content, template = 'report' } = options;
    
    const templates = {
      report: `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
            h1 { color: #333; border-bottom: 2px solid #333; padding-bottom: 10px; }
            .content { margin-top: 20px; }
            .footer { margin-top: 40px; font-size: 12px; color: #666; }
          </style>
        </head>
        <body>
          <h1>${title}</h1>
          <div class="content">
            ${content.replace(/\n/g, '<br>')}
          </div>
          <div class="footer">
            Generated by Document Assistant on ${new Date().toLocaleDateString()}
          </div>
        </body>
        </html>
      `,
      table: `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            table { border-collapse: collapse; width: 100%; margin-top: 20px; }
            th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            th { background-color: #f2f2f2; font-weight: bold; }
            tr:nth-child(even) { background-color: #f9f9f9; }
          </style>
        </head>
        <body>
          <h1>${title}</h1>
          <div>${content.replace(/\n/g, '<br>')}</div>
        </body>
        </html>
      `,
      presentation: `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
            .slide { background: rgba(255,255,255,0.1); padding: 40px; border-radius: 10px; backdrop-filter: blur(10px); }
            h1 { font-size: 2.5em; margin-bottom: 30px; text-align: center; }
            .content { font-size: 1.2em; line-height: 1.8; }
          </style>
        </head>
        <body>
          <div class="slide">
            <h1>${title}</h1>
            <div class="content">
              ${content.replace(/\n/g, '<br>')}
            </div>
          </div>
        </body>
        </html>
      `,
      custom: `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${title}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
            h1 { color: #2c3e50; }
          </style>
        </head>
        <body>
          <h1>${title}</h1>
          <div>${content.replace(/\n/g, '<br>')}</div>
        </body>
        </html>
      `
    };
    
    return templates[template] || templates.custom;
  }
  
  async generateAdvancedPDF(options: DocumentGenerationOptions): Promise<Buffer> {
    const html = await this.generateHTML(options);
    
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
      const page = await browser.newPage();
      await page.setContent(html, { waitUntil: 'networkidle0' });
      
      const pdf = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '20mm',
          bottom: '20mm',
          left: '20mm'
        }
      });
      
      return Buffer.from(pdf);
    } finally {
      await browser.close();
    }
  }
  
  async generate(options: DocumentGenerationOptions): Promise<Buffer | string> {
    switch (options.format) {
      case 'pdf':
        return options.template === 'custom' || options.template === 'presentation' 
          ? await this.generateAdvancedPDF(options)
          : await this.generatePDF(options);
      case 'excel':
        return await this.generateExcel(options);
      case 'html':
        return await this.generateHTML(options);
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }
}

export const documentGenerator = new DocumentGenerator();